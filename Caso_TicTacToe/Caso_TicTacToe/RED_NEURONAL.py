# -*- coding: utf-8 -*-
"""RED_NEURONAL.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1gyWOzGqMOEMoikS9H2Ur_ZT7F8M2XWuy
"""

# importar la libreria
import pandas as pd

#Crear el dataframe
training = pd.read_csv("tic_tac_toe.csv")
training.head(5)

#Cambiar datos a numericos
training["top-left-square"] = training["top-left-square"].apply(lambda toLabel: 0 if toLabel == 'x'  else 1 if toLabel == 'o'  else 2)
training["top-middle-square"] = training["top-middle-square"].apply(lambda toLabel: 0 if toLabel == 'x'  else 1 if toLabel == 'o'  else 2)
training["top-right-square"] = training["top-right-square"].apply(lambda toLabel: 0 if toLabel == 'x'  else 1 if toLabel == 'o'  else 2)
training["middle-left-square"] = training["middle-left-square"].apply(lambda toLabel: 0 if toLabel == 'x'  else 1 if toLabel == 'o'  else 2)
training["middle-middle-square"] = training["middle-middle-square"].apply(lambda toLabel: 0 if toLabel == 'x'  else 1 if toLabel == 'o'  else 2)
training["middle-right-square"] = training["middle-right-square"].apply(lambda toLabel: 0 if toLabel == 'x'  else 1 if toLabel == 'o'  else 2)
training["bottom-left-square"] = training["bottom-left-square"].apply(lambda toLabel: 0 if toLabel == 'x'  else 1 if toLabel == 'o'  else 2)
training["bottom-middle-square"] = training["bottom-middle-square"].apply(lambda toLabel: 0 if toLabel == 'x'  else 1 if toLabel == 'o'  else 2)
training["bottom-right-square"] = training["bottom-right-square"].apply(lambda toLabel: 0 if toLabel == 'x'  else 1 if toLabel == 'o'  else 2)
training["Class"] = training["Class"].apply(lambda toLabel: 0 if toLabel == 'positive' else 1)
training.head(5)

#Indentificar los input data y los target data

y_target = training["Class"].values
#print(y_target)

columns = ["top-left-square", "top-middle-square", "top-right-square", "middle-left-square", "middle-middle-square","middle-right-square","bottom-left-square","bottom-middle-square","bottom-right-square"]
x_input = training[list(columns)].values
print(x_input)

#Definir la estructura de la red nuronal para el aprendizaje

from keras.models import Sequential
from keras.layers.core import Dense

model = Sequential()
model.add(Dense(16,input_dim=9,activation='relu'))
model.add(Dense(16,activation='relu'))
model.add(Dense(1,activation='sigmoid'))

#Configurar los parametros de la red
model.compile(loss='binary_crossentropy',optimizer='adam',metrics='accuracy')

#Realizar el proceso de entrenamiento de la red neuronal
model.fit(x_input,y_target,epochs=1000)

#Evaluar la presicion
score = model.evaluate(x_input,y_target)
print("\n %s: %.2f%%" % (model.metrics_names[1],score[1]*100))

#respuesta = model.predict([[0,0,0,0,1,1,0,1,1]])
respuesta = model.predict([[0,2,1,0,1,0,1,2,2]])
print((respuesta))

model_json = model.to_json()
with open("model.json","w") as json_file:
  json_file.write(model_json)
model.save_weights("model.h5")
print("modelo guardado")

from keras.models import Model,model_from_json
json_file = open("model.json",'r')
loaded_model_json = json_file.read()
json_file.close()
loaded_model = model_from_json(loaded_model_json)
loaded_model.load_weights("model.h5")
print("modelo cargado en el disco")
model.compile(loss='binary_crossentropy',optimizer='adam',metrics='accuracy')
print(model.predict([[0,0,0,0,1,1,0,1,1]]).round())

"""MATRIZ"""

import numpy as np
from sklearn.metrics import confusion_matrix

#Leer datos csv
import pandas as pd
training = pd.read_csv("tic_tac_toe_final.csv")
training.info()
training.head(5)

#Cambiar datos a numericos
training["top-left-square"] = training["top-left-square"].apply(lambda toLabel: 0 if toLabel == 'x'  else 1 if toLabel == 'o'  else 2)
training["top-middle-square"] = training["top-middle-square"].apply(lambda toLabel: 0 if toLabel == 'x'  else 1 if toLabel == 'o'  else 2)
training["top-right-square"] = training["top-right-square"].apply(lambda toLabel: 0 if toLabel == 'x'  else 1 if toLabel == 'o'  else 2)
training["middle-left-square"] = training["middle-left-square"].apply(lambda toLabel: 0 if toLabel == 'x'  else 1 if toLabel == 'o'  else 2)
training["middle-middle-square"] = training["middle-middle-square"].apply(lambda toLabel: 0 if toLabel == 'x'  else 1 if toLabel == 'o'  else 2)
training["middle-right-square"] = training["middle-right-square"].apply(lambda toLabel: 0 if toLabel == 'x'  else 1 if toLabel == 'o'  else 2)
training["bottom-left-square"] = training["bottom-left-square"].apply(lambda toLabel: 0 if toLabel == 'x'  else 1 if toLabel == 'o'  else 2)
training["bottom-middle-square"] = training["bottom-middle-square"].apply(lambda toLabel: 0 if toLabel == 'x'  else 1 if toLabel == 'o'  else 2)
training["bottom-right-square"] = training["bottom-right-square"].apply(lambda toLabel: 0 if toLabel == 'x'  else 1 if toLabel == 'o'  else 2)
training["Class"] = training["Class"].apply(lambda toLabel: 0 if toLabel == 'positive' else 1)
training.head(5)

#Indentificar los input data y los target data

y_target2 = training["Class"].values
#print(y_target)

columns = ["top-left-square", "top-middle-square", "top-right-square", "middle-left-square", "middle-middle-square","middle-right-square","bottom-left-square","bottom-middle-square","bottom-right-square"]
x_input2 = training[list(columns)].values
print(x_input)

y_verd=np.array(y_target)
y_pred=np.array(y_target2)

confm=confusion_matrix(y_verd,y_pred)
print(confm)